#pragma kernel CSMain

struct Ray
{
    float3 origin, direction;
};

struct HitData
{
    float distance;
    float3 normal, color;
};

struct Sphere
{
    float3 position, color;
    float radius;
};


RWTexture2D<float4> Result;

float4x4 CameraToWorld, CameraInverseProjection;

RWStructuredBuffer<Sphere> Shapes;

static const uint MaxSteps = 100;
static const float MinDistance = 0.01f;
static const float MaxDistance = 100;
static const float infinity = 3.402823466e+38;


Ray CreateRay(float3 origin, float3 direction)
{
    Ray ray;
    ray.origin = origin;
    ray.direction = direction;

    return ray;
}

Ray CreateCameraRay(float2 uv)
{
    float3 origin = mul(CameraToWorld, float4(0, 0, 0, 1)).xyz;
    float3 direction = mul(CameraInverseProjection, float4(uv, 0, 1)).xyz;
    direction = mul(CameraToWorld, float4(direction, 0)).xyz;
    direction = normalize(direction);

    return CreateRay(origin, direction);
}

HitData CreateHitData(float distance, float3 normal, float3 color)
{
    HitData hit;
    hit.distance = distance;
    hit.normal = normal;
    hit.color = color;

    return hit;
}

Sphere CreateSphere(float3 position, float radius, float3 color)
{
    Sphere sphere;
    sphere.position = position;
    sphere.radius = radius;
    sphere.color = color;

    return sphere;
}


float SphereDistance(float3 position, Sphere sphere)
{
    return length(position - sphere.position) - sphere.radius;
}

Sphere GetMin(float3 position, out float distance)
{
    uint count, stride;
    Shapes.GetDimensions(count, stride);

    Sphere result;
    distance = MaxDistance;

    for (uint i = 0; i < count; i++)
    {
        Sphere shape = Shapes[i];
        float currentDistance = SphereDistance(position, shape);

        if (currentDistance < distance)
        {
            distance = currentDistance;
            result = shape;
        }
    }

    return result;
}

Sphere GetMax(float3 position, out float distance)
{
    uint count, stride;
    Shapes.GetDimensions(count, stride);

    Sphere result;
    distance = 0;

    for (uint i = 0; i < count; i++)
    {
        Sphere shape = Shapes[i];
        float currentDistance = SphereDistance(position, shape);

        if (currentDistance > distance)
        {
            distance = currentDistance;
            result = shape;
        }
    }

    return result;
}

float GetDistance(float3 position)
{
    float distance;
    Sphere sphere = GetMin(position, distance);

    return distance;
}

float3 GetNormal(float3 position)
{
    float distance = GetDistance(position);
    float2 e = float2(0.001f, 0);

    float3 normal = distance - float3(
        GetDistance(position - e.xyy),
        GetDistance(position - e.yxy),
        GetDistance(position - e.yyx)
        );

    return normalize(normal);
}

HitData RayMarch(Ray ray)
{
    float distance = 0;
    float3 normal = 0;
    float3 color = 0;

    for (uint i = 0; i < MaxSteps; i++)
    {
        float currentDistance;
        Sphere closest = GetMin(ray.origin, currentDistance);
        ray.origin += currentDistance * ray.direction;
        distance += currentDistance;

        if (distance >= MaxDistance)
            break;

        if (currentDistance <= MinDistance)
        {
            normal = GetNormal(ray.origin);
            color = closest.color;
            break;
        }
    }

    return CreateHitData(distance, normal, color);
}


[numthreads(32,32,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    float width, height;
    Result.GetDimensions(width, height);

    float2 uv = id.xy / float2(width, height) * 2 - 1;
    Ray ray = CreateCameraRay(uv);

    HitData hit = RayMarch(ray);

    float3 lightDirection = float3(-1, -1, 1);
    float3 lightColor = float3(1.0f, 0.956f, 0.8392f);
    float lightIntensity = 0.65f;

    float light = dot(hit.normal, -lightDirection) + 1;
    float3 color = hit.color * lerp(0.25f, 1, light) * lightColor * lightIntensity;
    Result[id.xy] = float4(color, 0);
}
